CREATE TABLE
  "public"."member" (
    "id" UUID NOT NULL,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "role" TEXT NOT NULL,
    "last_sign_in_at" TIMESTAMP WITH TIME ZONE
  );

ALTER TABLE "public"."member" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  "public"."previous_visit" (
    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "status" TEXT NOT NULL,
    "entered_at" TIMESTAMP WITH TIME ZONE,
    "served_at" TIMESTAMP WITH TIME ZONE,
    "completed_at" TIMESTAMP WITH TIME ZONE,
    "cancelled_at" TIMESTAMP WITH TIME ZONE,
    "station" BIGINT,
    "served_by_name" TEXT,
    "wait_minutes" BIGINT,
    "serve_minutes" BIGINT,
    "station_name" TEXT,
    "visitor" UUID,
    "visitor_name" TEXT
  );

ALTER TABLE "public"."previous_visit" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  "public"."station" (
    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "name" TEXT NOT NULL,
    "status" TEXT NOT NULL DEFAULT 'Closed'::TEXT,
    "opened_by" UUID,
    "opened_at" TIMESTAMP WITH TIME ZONE,
    "opened_by_name" TEXT,
    "called_at" TIMESTAMP WITH TIME ZONE,
    "served_at" TIMESTAMP WITH TIME ZONE,
    "visit" UUID,
    "visitor_name" TEXT
  );

ALTER TABLE "public"."station" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  "public"."visit" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid (),
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "visitor" UUID NOT NULL,
    "visitor_name" TEXT NOT NULL,
    "status" TEXT NOT NULL,
    "entered_at" TIMESTAMP WITH TIME ZONE,
    "served_at" TIMESTAMP WITH TIME ZONE,
    "served_by_name" TEXT,
    "completed_at" TIMESTAMP WITH TIME ZONE,
    "cancelled_at" TIMESTAMP WITH TIME ZONE,
    "station_name" TEXT,
    "station" BIGINT
  );

ALTER TABLE "public"."visit" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  "public"."visitor" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid (),
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "name" TEXT NOT NULL,
    "phone" TEXT NOT NULL,
    "last_visited_at" TIMESTAMP WITH TIME ZONE
  );

ALTER TABLE "public"."visitor" ENABLE ROW LEVEL SECURITY;

CREATE UNIQUE INDEX member_pkey ON public.member USING btree (id);

CREATE UNIQUE INDEX previous_visit_pkey ON public.previous_visit USING btree (id);

CREATE UNIQUE INDEX station_pkey ON public.station USING btree (id);

CREATE UNIQUE INDEX visit_pkey ON public.visit USING btree (id);

CREATE UNIQUE INDEX visitor_phone_key ON public.visitor USING btree (phone);

CREATE UNIQUE INDEX visitor_pkey ON public.visitor USING btree (id);

ALTER TABLE "public"."member"
ADD CONSTRAINT "member_pkey" PRIMARY KEY USING INDEX "member_pkey";

ALTER TABLE "public"."previous_visit"
ADD CONSTRAINT "previous_visit_pkey" PRIMARY KEY USING INDEX "previous_visit_pkey";

ALTER TABLE "public"."station"
ADD CONSTRAINT "station_pkey" PRIMARY KEY USING INDEX "station_pkey";

ALTER TABLE "public"."visit"
ADD CONSTRAINT "visit_pkey" PRIMARY KEY USING INDEX "visit_pkey";

ALTER TABLE "public"."visitor"
ADD CONSTRAINT "visitor_pkey" PRIMARY KEY USING INDEX "visitor_pkey";

ALTER TABLE "public"."member"
ADD CONSTRAINT "member_id_fkey" FOREIGN KEY (id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE NOT VALID;

ALTER TABLE "public"."member" VALIDATE CONSTRAINT "member_id_fkey";

ALTER TABLE "public"."station"
ADD CONSTRAINT "station_member_fkey" FOREIGN KEY (opened_by) REFERENCES member (id) ON UPDATE CASCADE ON DELETE CASCADE NOT VALID;

ALTER TABLE "public"."station" VALIDATE CONSTRAINT "station_member_fkey";

ALTER TABLE "public"."station"
ADD CONSTRAINT "station_visit_fkey" FOREIGN KEY (visit) REFERENCES visit (id) ON UPDATE CASCADE ON DELETE SET NULL NOT VALID;

ALTER TABLE "public"."station" VALIDATE CONSTRAINT "station_visit_fkey";

ALTER TABLE "public"."visit"
ADD CONSTRAINT "visit_station_fkey" FOREIGN KEY (station) REFERENCES station (id) ON UPDATE CASCADE ON DELETE SET NULL NOT VALID;

ALTER TABLE "public"."visit" VALIDATE CONSTRAINT "visit_station_fkey";

ALTER TABLE "public"."visit"
ADD CONSTRAINT "visit_visitor_fkey" FOREIGN KEY (visitor) REFERENCES visitor (id) ON UPDATE CASCADE ON DELETE CASCADE NOT VALID;

ALTER TABLE "public"."visit" VALIDATE CONSTRAINT "visit_visitor_fkey";

ALTER TABLE "public"."visitor"
ADD CONSTRAINT "visitor_phone_key" UNIQUE USING INDEX "visitor_phone_key";

SET
  check_function_bodies = OFF;

CREATE
OR REPLACE FUNCTION public.auth_users_i_u () RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $function$
BEGIN
  -- The first member will be the owner
  IF NOT EXISTS (SELECT 1 FROM public.member LIMIT 1) THEN
    INSERT INTO public.member(id, name, email, role, last_sign_in_at)
    VALUES (NEW.id, NEW.email, NEW.email, 'Owner', NEW.last_sign_in_at);
  ELSE
    -- Check if the user is already a team member
    IF EXISTS (SELECT 1 FROM public.member WHERE email = NEW.email) THEN
      -- Update the last_sign_in_at only
      UPDATE public.member
      SET last_sign_in_at = NEW.last_sign_in_at
      WHERE email = NEW.email;
    ELSE
      -- Create new member as 'Staff'
      INSERT INTO public.member(id, name, email, role, last_sign_in_at)
      VALUES (NEW.id, NEW.email, NEW.email, 'Staff', NEW.last_sign_in_at);
    END IF;
  END IF;
  RETURN NEW;
END;
$function$;

CREATE
OR REPLACE FUNCTION public.calculate_average_wait_minutes () RETURNS NUMERIC LANGUAGE plpgsql AS $function$DECLARE
    avg_wait_minutes NUMERIC;
    waiting NUMERIC;
BEGIN
    SELECT ROUND(COALESCE(AVG(wait_minutes), 0))::NUMERIC
    INTO avg_wait_minutes
    FROM previous_visit
    WHERE status = 'Completed'
      AND entered_at >= NOW() - INTERVAL '3 hours';

    RETURN avg_wait_minutes;
END;$function$;

CREATE POLICY "Enable all for authenticated" ON "public"."member" AS permissive FOR ALL TO authenticated USING (TRUE)
WITH
  CHECK (TRUE);

CREATE POLICY "Enable all for anon and authenticated" ON "public"."previous_visit" AS permissive FOR ALL TO authenticated,
anon USING (TRUE);

CREATE POLICY "Enable all for authenticated" ON "public"."station" AS permissive FOR ALL TO authenticated USING (TRUE);

CREATE POLICY "Enable all for anon and authenticated" ON "public"."visit" AS permissive FOR ALL TO anon,
authenticated USING (TRUE);

CREATE POLICY "Enable all for nano and authenticated" ON "public"."visitor" AS permissive FOR ALL TO anon,
authenticated USING (TRUE);

-- Create triggers on auth.users
CREATE TRIGGER users_i_u
AFTER INSERT
OR
UPDATE ON auth.users FOR EACH ROW
EXECUTE FUNCTION public.auth_users_i_u ();

-- Create new stations
INSERT INTO
  station (NAME)
VALUES
  ('Station 1'),
  ('Station 2'),
  ('Station 3');